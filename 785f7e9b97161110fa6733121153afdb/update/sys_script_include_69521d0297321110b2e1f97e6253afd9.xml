<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_53417_demo.SNB_LdapGroupService</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>SNB_LdapGroupService</name>
        <script><![CDATA[//@ts-ignore
var global = global || {};
/**
 * There was no where to put this information, so storing it here. These are the attributes
 * available for active directory LDAP entry:
 * actualdn,cn,description,displayName,distinguishedName,dn,
 * extensionAttributel,extensionAttribute2,groupType,instanceType,
 * internetEncoding, mail, mailNickname, me.mber, memberOf, name, objectCategory,
 * objectClass,objectGUID,objectSid,proxyAddresses,reportToOriginator,
 * sAMAccountName,sAMAccountType,showinAddressBook,source,uSNChanged,
 * uSNCreated,whenChanged,whenCreated
 */
/**
 * @class global.SNBLdapGroupService
 * @param {Object} [config] A configuration object
 * @param {boolean} [config.includeNestedGroups=false] Includes the members of any nested groups in resolved groups.
 * Otherwise only the top level members .will be included
 * @param {string} [config.ldapServerName=LDAP] The ldap server name of the LDAP server to query against. Will be set to
 * LDAP by default if isActiveDirectoryGroups is false, LDAP-AD otherwise
 * @param {boolean} [config.isActiveDirectoryGroups=false] Configures searches to run against active directory
 * @param {string} [config.ingestTypeName=SNB_LDAP_GROUP] The sys_user_group_type that is added to a new group that is ingested by this class.
 * This will be set to SNB_LDAP_GROUP if isActiveDirectoryGroups is false, SNB_LDAP_AD otherwise
 * @param {string} [config.searchRdn=ou=Groups] The rdn to limit searches of the directory to. For LDAP groups
 * this defaults to ou=Groups. Empty string is default for AD
 * @param {string} [config.logSource=SNBLdapGroupService] The source to add to log messages generated by this class. By default
 * SNBLdapGroupService
 */
global.SNBLdapGroupService = function(config) {
    config = config || {};
    this.includeNestedGroups = config.includeNestedGroups || false;
    this.isActiveDirectoryGroups = config.isActiveDirectoryGroups || false;
    this.logSource = config.logSource || 'SNBLdapGroupService';
    var defaultLdapServerName = this.isActiveDirectoryGroups ? 'LDAP-AD' : 'LDAP';
    this.ldapServerSysId = this._getLdapServerSysIdByName(config.ldapServerName || defaultLdapServerName);
    this.processedGroups = [];
    var defaultingestTypeName = this.isActiveDirectoryGroups ?
        this.getDefaultAdGroupTypeName() : this.getDefaultLdapGroupTypeName();
    this.ingestTypeName = config.ingestTypeName || defaultingestTypeName;
    var defaultSearchRdn = this.isActiveDirectoryGroups ? '' : 'ou=Groups~';
    this.searchRdn = config.searchRdn || defaultSearchRdn;
}

global.SNBLdapGroupService.prototype = {
    /**
     * .These properties are not accessible directly. You must call
     * LdapResult.get to retrieve these values, and LdapResult.get does not
     * return a JavaScript string. I'm not exactly sure what this is returning,
     * but you need to wrap the return in a string constructor like
     * String(result.get('cn')). If you don't do this i've found some string methods
     * do not work correctly
     * @typedef LdapResult
     * @property {string} en
     * @property {string} dn
     * @property {string} description Description of group
     * @property {string} source DN with a prefix of 'ldap:'
     * @property {string?} uniquemember Concatenated list of members.  Concatenated with 'A'. This will
     * be there for ou=Groups entries. Will be empty for dc=AD entries
     * @property {string?} member Concatenated list of members. Concatenated with 'A'. This will be
     * therefor dc=AD entries and not for ou=Group entries
     * @property {function} get Retrieves one of the properties
     */
    /**
     * @typedef LdapGroup
     * @property {string} cn
     * @property {string} dn
     * @property {string} uniquemember
     * @property {string[]} members
     * @property {boolean} isAdGroup
     */
    /**
     * @callback transformFn
     * @param {LdapResult} result A single result returned from an LDAP search
     * @returns {(LdapGroup | *)} Result of transformation
     */
    /**
     * Refresh the membership of a set of groups based on the group types
     * @param {string[]} typeNames A list of sys_user_group_type names
     */
    refreshGroupsByTypeNames: function(typeNames) {
        var groupSysIds = this.getGroupSysIdsByTypeNames(typeNames);
        this.refreshGroups(groupSysIds);
    },
    /**
     * Refreshes the membership of a set of groups based off group sys_id
     * @param {string[]} groupSysIds sys_ids of groups to referesh
     */
    refreshGroups: function(groupSysIds) {
        groupSysIds.forEach(this.refreshGroup.bind(this));
    },
    /**
     * Refreshes the membership of a group based off of a sys_id
     * @param {string} groupSysId group sys_id
     */
    refreshGroup: function(groupSysId) {
        var group = new GlideRecord('sys_user_group');
        if (group.get(groupSysId)) {
            var source = group.getValue('source');
            var name = this.getGroupShortNameFromSource(source);
            var ldapGroup = this.getGroupByName(name);
            if (ldapGroup) {
                this.clearMembers(groupSysId);
                this.addMembers(groupSysId, ldapGroup.members);
            } else {
                this._logError('Could not find group, ' + name + ' in LDAP');
            }
        } else {
            this._logError('Could not find group using sys_id: ' + groupSysId);
        }
    },
    /**
     * Ingests the given group from LDAP. Will create the group if the group
     * does not already exist. Only applies the type names to newly created groups.
     * If the group already exists the type isn't applied
     * @param {string} groupName Set of group names to ingest
     * @param {string[]} [types] List of sys_user_group_type names to apply to newly created groups
     * @returns {?GlideRecord} The ingested group or null if there was a problem
     */
    ingestGroup: function(groupName, types) {
        var groups = this.ingestGroups([groupName], types);
        if (groups.length > 0) {
            return groups[0];
        } else {
            null;
        }
    },
    /**
     * Retrieves a sys_user_group by distinguished name (DN)
     * @param {string} dn The distinguished name of the group to retrieve
     * @returns {?GlideRecord} the sys_user_group or null
     */
    getGroupByDn: function(dn) {
        var group = new GlideRecord('sys_user_group');
        if (group.get('source', 'ldap: ' + dn)) {
            return group;
        } else {
            return null;
        }
    },
    /**
    * Ingests the given group names from LDAP. Will create the group if the
    * does not already exist. Only applies the type names to newly created
    * If the group already exists the type isn't applied
    * @param {string[]} groupNames Set of group names to ingest
    * @param {string[]} [types] List of sys_user_group_type names to apply to
    newly created groups
    types);
    * @returns {GlideRecord[]} The list of ingested groups
    */
    ingestGroups: function(groupNames, types) {
        var queryParts = groupNames.map(function(name) {
            return '(cn=' + name + ')';
        });
        var query = '(|' + queryParts.join(' ') + ')';
        var ldapGroups = this.searchAndTransform(query, 10000);
        var me = this;
        return ldapGroups.map(function(ldapGroup) {
            var existingGroup = me.getGroupByDn(ldapGroup.dn);
            if (existingGroup) {
                return existingGroup;
            } else {
                return me.createGroupFromLdapGroup(ldapGroup, types);
            }
        });
    },
    /**
     * Retrieves a list of sys_user_group sys_ids by finding groups that have
     * all the provided type names passed in
     * @param {string[]} typeNames List of typenames to find group sys_ids
     * @returns {string[]} sys_ids of group names that have all type names
     */
    getGroupSysIdsByTypeNames: function(typeNames) {
        var me = this;
        var group = new GlideAggregate('sys_user_group');
        group.groupBy('sys_id');
        typeNames.forEach(function(name) {
            group.addQuery('type', 'CONTAINS', me.getType(name));
        });
        group.query();
        var sysIds = [];
        while (group.next()) {
            sysIds.push(group.getValue('sys_id'));
        }
        return sysIds;
    },

    /**
     * Returns the type sys_id by using the provided type name
     * @param {string} typeName Type name from sys_user_group_type
     * @returns {string} sys_id of the type or null if type not found
     */
    getType: function(typeName) {
        var types = this.getTypes([typeName]);
        if (types.length > 0) {
            return types[0];
        } else {
            return null;
        }
    },
    /**
     * Returns the sys_ids of the sys_user_group_type by using the provided
     * type names
     * @param {string[]} typeNames List of names of sys_user_group_type
     * @returns {string[]} List of sys_ids of the types
     */
    getTypes: function(typeNames) {
        if (typeNames && typeNames.length > 0) {
            var type = new GlideRecord('sys_user_group_type');
            type.addQuery('name', 'IN', typeNames);
            type.query();
            var types = [];
            while (type.next()) {
                types.push(type.getUniqueValue());
            }
            return types;
        } else {}
        return [];
    },
    /**
     * Creates the marker for newly ingested groups by this class. This is so
     * it is easy to find groups created by this class, so they can be updated
     * or monitored
     * @returns {string} The sys_id of the sys_user_group_type that represents the type
     * marker
     */
    getOrCreateIngestGroupType: function() {
        var type = new GlideRecord('sys_user_group_type');
        var ingestTypeName = this.ingestTypeName;
        if (type.get('name', ingestTypeName)) {} else {
            return type.getUniqueValue();
        }
        type.newRecord();
        type.name = ingestTypeName;
        type.description = 'Marker for groups ingested by SNBLdapGroupService';
        type.update();
        return type.getUniqueValue();
    },
    /**
     * Creates a sys_user_group from an LDAP group. Applies the provided type names to
     * the new group
     * @param {LdapGroup} ldapGroup
     * @param {string[]} [types] List of sys_user_group_type names to apply to the created group
     * @returns {GlideRecord} The created sys_user_group
     */
    createGroupFromLdapGroup: function(ldapGroup, types) {
        var group = new GlideRecord('sys_user_group');
        group.newRecord();
        group.name = this.getNameFromDn(ldapGroup.dn);
        group.source = 'ldap: ' + ldapGroup.dn;
        group.type = [].concat(this.getOrCreateIngestGroupType(),
            this.getTypes(types)).join(', ');
        group.update();
        this.addMembers(group.getUniqueValue(), ldapGroup.members);
        return group;
    },

    /**
     * Removes all the members of a group given a sys_id
     * @param {string} groupSysId sys_id of group to remove members
     */
    clearMembers: function(groupSysId) {
        if (!groupSysId) return;
        var groupMember = new GlideRecord('sys_user_grmember');
        groupMember.addQuery('group', groupSysId);
        groupMember.query();
        groupMember.deleteMultiple();
    },

    /**
     * Adds the given members distinguished by their DNs to the group by
     * the provided group sys_id
     * @param {string} groupSysId sys_id of group to add members
     * @param {string[]} memberDNs List DNs for people to add to group
     * @param {string[]} [processedGroups] DNs for groups that have already been processed. Used for
     * recursive calls
     */
    addMembers: function(groupSysId, memberDNs, processedGroups) {
        var me = this;
        var people = memberDNs.filter(function(member) {
            return new RegExp(me.getPersonRegex(), 'i').test(member);
        });
        if (people.length > 0) {
            var user = new GlideAggregate('sys_user');
            user.groupBy('sys_id');
            user.groupBy('employee_number');
            user.groupBy('u_dn');
            var peopleCopy = [].concat(people);
            var userCondition;
            var peopleEmployeeNumber;
            if (this.isActiveDirectoryGroups) {
                peopleEmployeeNumber = this._getActiveDirectoryUserEmployeeNumbers(peopleCopy);
                userCondition = user.addQuery('employee_number', 'IN', peopleEmployeeNumber);
            } else {
                userCondition = user.addQuery('u_dn', peopleCopy.shift());
                peopleCopy.reduce(function(condition, person) {
                    return condition.addOrCondition('u_dn', person);
                }, userCondition);
            }
            user.query();
            //used to track people we didn't find in ServiceNow that exist in LDAP
            var missingPeople;
            if (this.isActiveDirectoryGroups) {
                missingPeople = peopleEmployeeNumber;
            } else {
                missingPeople = [].concat(people);
            }
            while (user.next()) {
                var matchField = this.isActiveDirectoryGroups ? 'employee_number' : 'u_dn';
                var index = missingPeople.indexOf(user.getValue(matchField));
                if (index >= 0) {
                    missingPeople.splice(index, 1);
                }
                var groupMember = new GlideRecord('sys_user_grmember');
                groupMember.addQuery('user', user.getValue('sys_id'));
                groupMember.addQuery('group', groupSysId);
                groupMember.query();
                if (groupMember.hasNext()) {
                    continue;
                }
                groupMember.newRecord();
                groupMember.group = groupSysId;
                groupMember.user = user.getValue('sys_id');
                groupMember.update();
            }
            if (missingPeople.length > 0) {
                var targetGroup = new GlideRecord('sys_user_group');
                targetGroup.get(groupSysId);
                this._logWarning('SNBLdapGroupService.addMembers  Could not find people: ' + missingPeople + ' for group: ' + targetGroup.getDisplayValue());
            }
        }
        if (this.includeNestedGroups) {
            var groupDNs = memberDNs.filter(function(member) {
                return new RegExp(me.getGroupRegex(), 'i').test(member);
            });
            var groups = groupDNs.filter(function(groupDN) {
                var alreadyProcessed = processedGroups.indexOf(groupDN) >= 0;
                return !alreadyProcessed;
            }).map(function(groupDN) {
                var shortCn = me.getGroupShortNameFromDn(groupDN);
                return me.getGroupByName(shortCn);
            }).filter(function(group) {
                return !!group;
            });
            groups.forEach(function(group) {
                //if processed groups is not initialized this is the first call the group
                //need to initialize this argument with the DN of
                //that all members are added to.
                if (!processedGroups) {
                    var targetGroup = new GlideRecord('sys_user_group');
                    targetGroup.get(groupSysId);
                    var dn = me.getDnFromSource(targetGroup.getValue('source'));
                    processedGroups = [dn];
                }
                me.addMembers(groupSysId, group.members, processedGroups);
            });
        }
    },
    /**
     * Transforms source attribute into a common name. Source field contains the DN that
     * is prefixed by 'ldap:'. This transforms that into just a common name
     * @param {string} source Value of source field in LdapResult or sys_user_group
     * @returns {string} primary common name of the group. This is the name used in the ON the DN
     */
    getGroupShortNameFromSource: function(source) {
        var dn = this.getDnFromSource(source);
        return this.getGroupShortNameFromDn(dn);
    },
    /**
    * Transforms DN attribute into a common name. ~t pulls the CN portion of
    * @param {string} groupDN Value of DN field in LdapResult or sys_user_group
    * @returns {string} primary common name of the group. This is the name
    used in the DN
    */
    getGroupShortNameFromDn: function(groupDN) {
        var dnParts = groupDN.split(', ');
        var cn = dnParts[0];
        var cnParts = cn.split('=');
        var shorten = cnParts[1];
        return shorten;
    },
    /**
     * Returns an LdapGroup for the given group name or null
     * @param {string} groupName An individual group alias
     * @param {transformFn} [transformFn]
     * @param {string[]} [processedGroups] List of processed groups by DN.
     * Used for recursive calls
     * @returns {(LdapGroup|*)}
     */
    getGroupByName: function(groupName, transformFn, processedGroups) {
        var results = this.searchAndTransform('(cn=' + groupName + ')', 1, transformFn, processedGroups);
        if (results.length > 0) {
            return results[0];
        } else {
            return null;
        }
    },
    /**
     * Searches for groups using a begins with query. The term is all or part of a group alias.
     * This returns a list of the found group names. The names will be the primary group names.
     * These are the group name used in the group's DN. This can be different than the ServiceNow
     * group name, because the ServiceNow group name may be the concatenated group aliases using the 'A'
     * @param {string} term common name of group to look for
     * @param {number} limit Maximum number of search results
     * @param {boolean} onlyMailGroups true if you only want mail groups
     * @returns {string[]} List of found primary group names
     */
    searchBeginsWith: function(term, limit, onlyMailGroups) {
        if (!term) {
            return [];
        }
        var query = onlyMailGroups ? '(&(en=' + term + ' *)(descript i on=domino_whitepages_group))' : '(en=' + term + ' *)';
        var groups = this.searchAndTransform(query, limit);
        if (limit != 0 && groups.length > limit) {
            groups.length = limit;
        }
        var transformedGroups = [];
        for (var i = 0; i < groups.length; i++) {
            transformedGroups.push(this.getNameFromDn(groups[i].dn));
        }
        return transformedGroups;
    },
    /**
     * Searches for groups using a contains query . The term is all or part of a group alias.
     * This returns a list of the found group names. The names will be the primary group names.
     * These are the group name used in the group's DN. This can be different than the ServiceNow
     * group name, because the ServiceNow group name may be the concatenated group aliases using the·~·
     * @param {string} term common name of group to look for
     * @param {number} limit Maximum number of search results
     * @param {boolean} onlyMailGroups true if you only want mail groups
     * @returns {string[]} List of found primary group names
     */
    search: function(term, limit, onlyMailGroups) {
        if (!term) {
            return [];
        }
        var query = onlyMailGroups ? '(&(en=*' + term + '*)(description=domino_whitepages_group))' : '(en=*' + term + '*)';
        var groups = this.searchAndTransform(query, limit);
        if (limit != 0 && groups.length > limit) {
            groups.length = limit;
        }
        var transformedGroups = [];
        for (var i = 0; i < groups.length; i++) {
            transformedGroups.push(this.getNameFromDn(groups[i].dn));
        }
        return transformedGroups;
    },
    /**
     * Returns true if group is an active directory group as opposed to a traditional LDAP
     * group . AD groups come straight from active directory and have slightly different
     * attributes
     * @param {string} dn DN of AD group
     */
    isActiveDirectoryGroup: function(dn) {
        //checks DN for the string dc=ad which signifies
        //that the entry is in the
        return /\bdc=ad\b/i.test(dn);
    },
    /**
     * Searches LDAP using the provided query. Will only pull back groups
     * because there is a RDN filter placed on the search. Query must be a valid LDAP query
     * You can provide an optional transformFn. If not provided a transform will
     * be performed on the query results
     * @param {string} query A valid LDAP query
     * @param {number} limit Maximum number of results
     * @param {transformFn} [transformFn] Function to transform the result of the LDAP query
     * @param {string[]} [processedGroups] Accumulator for recursive query
     * @returns {(LdapGroup[]|*)} The list of found groups from LDAP
     */
    searchAndTransform: function(query, limit, transformFn, processedGroups) {
        var me = this;
        transformFn = transformFn || function(result) {
            var uniquemember = me.getUniqueMember(result);
            var members = me.getMembers(result, processedGroups);
            return {
                en: String(result.get('cn')),
                dn: String(result.get('dn')),
                uniquemember: uniquemember,
                members: members,
                isAdGroup: me.isActiveDirectoryGroup(String(result.get('dn')))
            };
        };
        //@ts-ignore
        var ldap = new GlideLDAP();
        ldap.setConfigID(this._getLdapServerSysId());
        var ldapResult = ldap.getMatching(this.getSearchRdn(), query, false, limit || 1000);
        var groups = [];
        var result;
        while (ldapResult.hasMore()) {
            result = ldapResult.next();
            groups.push(transformFn(result));
        }
        return groups;
    },
    /**
     * @returns {string} The rdn to limit searches of the directory to
     */
    getSearchRdn: function() {
        return this.searchRdn;
    },
    /**
     * Retrieves the value for the members in a group. This can vary depending
     * on the type of LDAP entry retrieved
     * @param {LdapResult} result
     */
    getUniqueMember: function(result) {
        return this.isActiveDirectoryGroup(String(result.get('dn'))) ?
            String(result.get('member')) :
            String(result.get('uniquemember'));
    },
    /**
     * Returns a regex to apply against a DN returned from LDAP to determine if the DN
     * is a group
     * @returns {string} Regex to apply against a DN to determine if DN is a group
     */
    getGroupRegex: function() {
        return this.isActiveDirectoryGroups ?
            //This looks odd, but this matches everything that is not the getPersonRegex
            '^(?!CN=\\w{7}(-\\w{3})?,.*$)' :
            'ou=Groups';
    },
    /**
     * Returns a regex to apply against a DN returned from LDAP to determine if the DN
     * is a person
     * @returns {string} Regex to apply against a DN to determine if DN is a person
     */
    getPersonRegex: function() {
        return this.isActiveDirectoryGroups ?
            //Matches 7 characters followed by an optional dash and 3 characters
            //like abcdefg or abcdefg-adm
            '^CN=\\w{7}(-\\w{3})?,' :
            'ou=People';
    },
    /**
     * Retrieves all the members of a group using an LdapResult. This can potentially resolve
     * nested groups recursively.
     * @param {LdapResult} result Result from an LDAP search
     * @param {?string[]} processedGroups Accumulated list of already processed groups specified by DN.
     * Used for recursive calls
     * @returns {string[]} List of DNs of all the people in a group
     */
    getMembers: function(result, processedGroups) {
        var me = this;
        var uniquemember = this.getUniqueMember(result);
        var memberDNs = uniquemember ? uniquemember.split('A') : [];
        var people = memberDNs.filter(function(member) {
            return new RegExp(me.getPersonRegex(), 'i').test(member);
        });
        gs.debug('people:' + people.join('\n'));
        var nestedPeople = [];
        if (this.includeNestedGroups) {

            if (!processedGroups) {
                processedGroups = [String(result.get('dn'))];
            }
            var groupDNs = memberDNs.filter(function(member) {
                return new RegExp(me.getGroupRegex(), 'i').test(member);
            });
            gs.debug('groups: ' + groupDNs.join('\n'));
            var groups = groupDNs.filter(function(groupDN) {
                var alreadyProcessed = processedGroups.indexOf(groupDN) >= 0;
                return !alreadyProcessed;
            }).map(function(groupDN) {
                var dnParts = groupDN.split(', ');
                var en = dnParts[0];
                var cnParts = en.split('=');
                var shortCn = cnParts[1];
                processedGroups.push(groupDN);
                return me.getGroupByName(shortCn, null, processedGroups);
            }).filter(function(group) {
                return !!group;
            });
            nestedPeople = groups.reduce(function(people, group) {
                return [].concat(people, group.members);
            }, []);
        }
        return new global.ArrayUtil().unique([].concat(people, nestedPeople));
    },
    /**
     * Returns if this group exists in LDAP
     * @param {string} groupName One of the aliases of a group
     * @returns {boolean} Returns true if alias found
     */
    exists: function(groupName) {
        return !!this.getGroupByName(groupName);
    },
    /**
    * Transforms source attribute into a DN
    * @param {string} source Value of source field in LdapResult or
    sys_user_group
    * @returns {string} The DN from the source field
    */
    getDnFromSource: function(source) {
        //chops off ldap: from source to get true DN
        return source.substr('ldap:'.length);
    },
    /**
     * Retrieves the primary group name from DN. This is the CN attribute associated table
     * with the DN
     * @param {string} dn
     * @returns {string} The primary group name
     */
    getNameFromDn: function(dn) {
        var cn = dn.split(', ')[0];
        if (cn) {
            var name = cn.split('=');
            return name[1];
        } else {
            return '';
        }
    },
    /**
     * Returns the sys_id of the LDAP server entry in the ldap_server_config
     */
    _getLdapServerSysId: function() {
        return this.ldapServerSysId;
    },

    /**
     * Returns the sys_id of the LDAP server by name
     * @param {string} name The name of the LDAP server
     * @returns {string} LDAP server sys_id
     */
    _getLdapServerSysIdByName: function(name) {
        var ldap = new GlideRecord('ldap_server_config');
        if (ldap.get('name', name)) {
            return ldap.getUniqueValue();
        } else {
            throw 'Could not find LDAP server using name: ' + name;
        }
    },
    /**
     * @returns {string} The default sys_user_group_type name for a LDAP group
     */
    getDefaultLdapGroupTypeName: function() {
        return 'SNB LDAP GROUP'
    },
    /**
     * @returns {string} The default sys_user_group_type name for an AD group
     */
    getDefaultAdGroupTypeName: function() {
        return 'SNB_AD_GROUP';
    },
    /**
     * Logs a warn level message with the log source provided at construction
     * @param {string} message Log message
     */
    _logWarning: function(message) {
        gs.logWarning(message, this.logSource);
    },
    /**
     * Logs a error level message with the log source provided at construction
     * @param {string} message
     */
    _logError: function(message) {
        gs.logError(message, this.logSource);
    },
    /**
     * Takes the member list from an LDAP search of active directory and retrieves the
     * associated employeenumbers by searching for the users in LDAP
     * @param {string[]} members List of member DNs to retrieve EmployeeNumbers
     * @returns {string[]} List of EmployeeNUmbers
     */
    _getActiveDirectoryUserEmployeeNumbers: function(members) {
        var existingSearchRdn = this.searchRdn;
        this.searchRdn = '';
        var me = this;
        var queryParts = members.map(function(member) {
            return '(cn=' + me.getNameFromDn(member) + ')';
        });
        var query = '(|' + queryParts.join(' ') + ')';
        var results = this.searchAndTransform(query, 1000, function(ldapResult) {
            var employeeNumber = ldapResult.get('employeeNumber');
            return employeeNumber ? String(employeeNumber) : null;
        }).filter(function(employeeNumber) {
            return !!employeeNumber;
        });
        this.searchRdn = existingSearchRdn;
        return new global.ArrayUtil().unique(results);
    },
    type: 'SNBLdapGroupService'
}]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-10-28 19:54:28</sys_created_on>
        <sys_id>69521d0297321110b2e1f97e6253afd9</sys_id>
        <sys_name>SNB_LdapGroupService</sys_name>
        <sys_package display_value="Demo" source="x_53417_demo">785f7e9b97161110fa6733121153afdb</sys_package>
        <sys_policy/>
        <sys_scope display_value="Demo">785f7e9b97161110fa6733121153afdb</sys_scope>
        <sys_update_name>sys_script_include_69521d0297321110b2e1f97e6253afd9</sys_update_name>
    </sys_script_include>
</record_update>
